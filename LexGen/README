The procedure generate-LANG-lexer takes a description, which is an
associative list of the form ((Identifier RegExp) ...), and generates
token reading code.

Each variant of generate-LANG-lexer also takes an optional second
argument, which can be a filename or an output port where the
generated output will be sent; it defaults to (current-output-port).

The generated code fragment has the nullary procedure scanner0 as
entry point.  The fragment assumes its context provides the procedures
consumeChar(), scanChar(), and accept(Token), as well as a constant
value named EOF, where

See regexp.sch for the actual syntax for regexps.  As best I can tell
from reading and experimentation, the data definitions are roughly:

;; An Identifier is a Symbol that when printed is a legal identifer
;; fragment for the target language.  (For example, using a sequence
;; of upper- and lower-case letters from the basic Latin alphabet.)

;; A RegExp is one of:
;; - Character                    -- literal
;; - [Listof RegExp]              -- catentation
;; - (cons '! [Listof RegExp])    -- alternation
;; - (list '* RegExp)             -- Kleene star
;; - (list '+ RegExp)             -- (+ R) is same as (R (* R))
